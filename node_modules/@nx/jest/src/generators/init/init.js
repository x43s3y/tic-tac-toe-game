"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jestInitGenerator = void 0;
const devkit_1 = require("@nx/devkit");
const js_1 = require("@nx/js");
const find_root_jest_files_1 = require("../../utils/config/find-root-jest-files");
const versions_1 = require("../../utils/versions");
const schemaDefaults = {
    compiler: 'tsc',
    js: false,
    rootProject: false,
    testEnvironment: 'jsdom',
};
function generateGlobalConfig(tree, isJS) {
    const contents = isJS
        ? (0, devkit_1.stripIndents) `
    const { getJestProjects } = require('@nx/jest');

    module.exports = {
      projects: getJestProjects()
    };`
        : (0, devkit_1.stripIndents) `
    import { getJestProjects } from '@nx/jest';

    export default {
     projects: getJestProjects()
    };`;
    tree.write(`jest.config.${isJS ? 'js' : 'ts'}`, contents);
}
function createJestConfig(tree, options) {
    if (!tree.exists('jest.preset.js')) {
        // preset is always js file.
        tree.write(`jest.preset.js`, `
      const nxPreset = require('@nx/jest/preset').default;

      module.exports = { ...nxPreset }`);
        updateProductionFileSet(tree);
        addJestTargetDefaults(tree);
    }
    if (options.rootProject) {
        // we don't want any config to be made because the `configurationGenerator` will do it.
        // will copy the template config file
        return;
    }
    const rootJestPath = (0, find_root_jest_files_1.findRootJestConfig)(tree);
    if (!rootJestPath) {
        // if there's not root jest config, we will create one and return
        // this can happen when:
        // - root jest config was renamed => in which case there is migration needed
        // - root project didn't have jest setup => again, no migration is needed
        generateGlobalConfig(tree, options.js);
        return;
    }
    if (tree.exists(rootJestPath)) {
        // moving from root project config to monorepo-style config
        const projects = (0, devkit_1.getProjects)(tree);
        const projectNames = Array.from(projects.keys());
        const rootProject = projectNames.find((projectName) => projects.get(projectName)?.root === '.');
        // root project might have been removed,
        // if it's missing there's nothing to migrate
        if (rootProject) {
            const rootProjectConfig = projects.get(rootProject);
            const jestTarget = Object.values(rootProjectConfig.targets || {}).find((t) => t?.executor === '@nx/jest:jest' || t?.executor === '@nrwl/jest:jest');
            const isProjectConfig = jestTarget?.options?.jestConfig === rootJestPath;
            // if root project doesn't have jest target, there's nothing to migrate
            if (isProjectConfig) {
                const jestProjectConfig = `jest.config.${rootProjectConfig.projectType === 'application' ? 'app' : 'lib'}.${options.js ? 'js' : 'ts'}`;
                tree.rename(rootJestPath, jestProjectConfig);
                jestTarget.options.jestConfig = jestProjectConfig;
                (0, devkit_1.updateProjectConfiguration)(tree, rootProject, rootProjectConfig);
            }
            // generate new global config as it was move to project config or is missing
            generateGlobalConfig(tree, options.js);
        }
    }
}
function updateProductionFileSet(tree) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    const productionFileSet = nxJson.namedInputs?.production;
    if (productionFileSet) {
        // This is one of the patterns in the default jest patterns
        productionFileSet.push(
        // Remove spec, test, and snapshots from the production fileset
        '!{projectRoot}/**/?(*.)+(spec|test).[jt]s?(x)?(.snap)', 
        // Remove tsconfig.spec.json
        '!{projectRoot}/tsconfig.spec.json', 
        // Remove jest.config.js/ts
        '!{projectRoot}/jest.config.[jt]s', 
        // Remove test-setup.js/ts
        // TODO(meeroslav) this should be standardized
        '!{projectRoot}/src/test-setup.[jt]s', '!{projectRoot}/test-setup.[jt]s');
        // Dedupe and set
        nxJson.namedInputs.production = Array.from(new Set(productionFileSet));
    }
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
function addJestTargetDefaults(tree) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    const productionFileSet = nxJson.namedInputs?.production;
    nxJson.targetDefaults ??= {};
    nxJson.targetDefaults['@nx/jest:jest'] ??= {};
    nxJson.targetDefaults['@nx/jest:jest'].cache ??= true;
    // Test targets depend on all their project's sources + production sources of dependencies
    nxJson.targetDefaults['@nx/jest:jest'].inputs ??= [
        'default',
        productionFileSet ? '^production' : '^default',
        '{workspaceRoot}/jest.preset.js',
    ];
    nxJson.targetDefaults['@nx/jest:jest'].options ??= {
        passWithNoTests: true,
    };
    nxJson.targetDefaults['@nx/jest:jest'].configurations ??= {
        ci: {
            ci: true,
            codeCoverage: true,
        },
    };
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
function updateDependencies(tree, options) {
    const dependencies = {
        tslib: versions_1.tslibVersion,
    };
    const devDeps = {
        '@nx/jest': versions_1.nxVersion,
        jest: versions_1.jestVersion,
        // because the default jest-preset uses ts-jest,
        // jest will throw an error if it's not installed
        // even if not using it in overriding transformers
        'ts-jest': versions_1.tsJestVersion,
    };
    if (options.testEnvironment !== 'none') {
        devDeps[`jest-environment-${options.testEnvironment}`] = versions_1.jestVersion;
    }
    if (!options.js) {
        devDeps['ts-node'] = versions_1.tsNodeVersion;
        devDeps['@types/jest'] = versions_1.jestTypesVersion;
        devDeps['@types/node'] = versions_1.typesNodeVersion;
    }
    if (options.compiler === 'babel' || options.babelJest) {
        devDeps['babel-jest'] = versions_1.babelJestVersion;
        // in some cases @nx/js will not already be present i.e. node only projects
        devDeps['@nx/js'] = versions_1.nxVersion;
    }
    else if (options.compiler === 'swc') {
        devDeps['@swc/jest'] = versions_1.swcJestVersion;
    }
    return (0, devkit_1.addDependenciesToPackageJson)(tree, dependencies, devDeps);
}
function updateExtensions(host) {
    if (!host.exists('.vscode/extensions.json')) {
        return;
    }
    (0, devkit_1.updateJson)(host, '.vscode/extensions.json', (json) => {
        json.recommendations = json.recommendations || [];
        const extension = 'firsttris.vscode-jest-runner';
        if (!json.recommendations.includes(extension)) {
            json.recommendations.push(extension);
        }
        return json;
    });
}
async function jestInitGenerator(tree, schema) {
    const options = normalizeOptions(schema);
    const tasks = [];
    tasks.push(await (0, js_1.initGenerator)(tree, {
        ...schema,
        skipFormat: true,
    }));
    createJestConfig(tree, options);
    if (!options.skipPackageJson) {
        (0, devkit_1.removeDependenciesFromPackageJson)(tree, ['@nx/jest'], []);
        const installTask = updateDependencies(tree, options);
        tasks.push(installTask);
    }
    updateExtensions(tree);
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.jestInitGenerator = jestInitGenerator;
function normalizeOptions(options) {
    return {
        ...schemaDefaults,
        ...options,
    };
}
exports.default = jestInitGenerator;
