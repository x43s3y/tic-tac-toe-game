"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.angularInitGenerator = void 0;
const devkit_1 = require("@nx/devkit");
const jest_1 = require("@nx/jest");
const eslint_1 = require("@nx/eslint");
const js_1 = require("@nx/js");
const test_runners_1 = require("../../utils/test-runners");
const version_utils_1 = require("../utils/version-utils");
const versions_1 = require("../../utils/versions");
async function angularInitGenerator(tree, rawOptions) {
    const tasks = [];
    const options = normalizeOptions(rawOptions);
    const pkgVersions = (0, version_utils_1.versions)(tree);
    const peerDepsToInstall = ['@angular-devkit/core'];
    let devkitVersion;
    peerDepsToInstall.forEach((pkg) => {
        const packageVersion = (0, version_utils_1.getInstalledPackageVersion)(tree, pkg);
        if (!packageVersion) {
            devkitVersion ??=
                (0, version_utils_1.getInstalledPackageVersion)(tree, '@angular-devkit/build-angular') ??
                    pkgVersions.angularDevkitVersion;
            try {
                (0, devkit_1.ensurePackage)(pkg, devkitVersion);
            }
            catch {
                // @schematics/angular cannot be required so this fails but this will still allow wrapping the schematic later on
            }
            if (!options.skipPackageJson) {
                tasks.push((0, devkit_1.addDependenciesToPackageJson)(tree, {}, { [pkg]: devkitVersion }));
            }
        }
    });
    setDefaults(tree, options);
    const jsTask = await (0, js_1.initGenerator)(tree, {
        ...options,
        tsConfigName: options.rootProject ? 'tsconfig.json' : 'tsconfig.base.json',
        js: false,
        skipFormat: true,
    });
    tasks.push(jsTask);
    if (!options.skipPackageJson) {
        tasks.push(updateDependencies(tree, pkgVersions));
    }
    const unitTestTask = await addUnitTestRunner(tree, options, pkgVersions.jestPresetAngularVersion);
    tasks.push(unitTestTask);
    const e2eTask = await addE2ETestRunner(tree, options);
    tasks.push(e2eTask);
    ignoreAngularCacheDirectory(tree);
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.angularInitGenerator = angularInitGenerator;
function normalizeOptions(options) {
    return {
        e2eTestRunner: options.e2eTestRunner ?? test_runners_1.E2eTestRunner.Cypress,
        linter: options.linter ?? eslint_1.Linter.EsLint,
        skipFormat: options.skipFormat ?? false,
        skipInstall: options.skipInstall ?? false,
        skipPackageJson: options.skipPackageJson ?? false,
        style: options.style ?? 'css',
        unitTestRunner: options.unitTestRunner ?? test_runners_1.UnitTestRunner.Jest,
        rootProject: options.rootProject,
    };
}
function setDefaults(host, options) {
    const nxJson = (0, devkit_1.readNxJson)(host);
    nxJson.generators = nxJson.generators || {};
    nxJson.generators['@nx/angular:application'] = {
        style: options.style,
        linter: options.linter,
        unitTestRunner: options.unitTestRunner,
        e2eTestRunner: options.e2eTestRunner,
        ...(nxJson.generators['@nx/angular:application'] || {}),
    };
    nxJson.generators['@nx/angular:library'] = {
        linter: options.linter,
        unitTestRunner: options.unitTestRunner,
        ...(nxJson.generators['@nx/angular:library'] || {}),
    };
    nxJson.generators['@nx/angular:component'] = {
        style: options.style,
        ...(nxJson.generators['@nx/angular:component'] || {}),
    };
    (0, devkit_1.updateNxJson)(host, nxJson);
}
function updateDependencies(tree, versions) {
    const angularVersion = (0, version_utils_1.getInstalledPackageVersion)(tree, '@angular/core') ??
        versions.angularVersion;
    const angularDevkitVersion = (0, version_utils_1.getInstalledPackageVersion)(tree, '@angular-devkit/build-angular') ??
        versions.angularDevkitVersion;
    const rxjsVersion = (0, version_utils_1.getInstalledPackageVersion)(tree, 'rxjs') ?? versions.rxjsVersion;
    const tsLibVersion = (0, version_utils_1.getInstalledPackageVersion)(tree, 'tslib') ?? versions.tsLibVersion;
    const zoneJsVersion = (0, version_utils_1.getInstalledPackageVersion)(tree, 'zone.js') ?? versions.zoneJsVersion;
    return (0, version_utils_1.addDependenciesToPackageJsonIfDontExist)(tree, {
        '@angular/animations': angularVersion,
        '@angular/common': angularVersion,
        '@angular/compiler': angularVersion,
        '@angular/core': angularVersion,
        '@angular/forms': angularVersion,
        '@angular/platform-browser': angularVersion,
        '@angular/platform-browser-dynamic': angularVersion,
        '@angular/router': angularVersion,
        rxjs: rxjsVersion,
        tslib: tsLibVersion,
        'zone.js': zoneJsVersion,
    }, {
        '@angular/cli': angularDevkitVersion,
        '@angular/compiler-cli': angularVersion,
        '@angular/language-service': angularVersion,
        '@angular-devkit/build-angular': angularDevkitVersion,
        '@angular-devkit/schematics': angularDevkitVersion,
        '@schematics/angular': angularDevkitVersion,
    });
}
async function addUnitTestRunner(tree, options, jestPresetAngularVersion) {
    switch (options.unitTestRunner) {
        case test_runners_1.UnitTestRunner.Jest:
            if (!options.skipPackageJson) {
                process.env.npm_config_legacy_peer_deps ??= 'true';
                (0, version_utils_1.addDependenciesToPackageJsonIfDontExist)(tree, {}, {
                    'jest-preset-angular': jestPresetAngularVersion,
                });
            }
            return (0, jest_1.jestInitGenerator)(tree, {
                skipPackageJson: options.skipPackageJson,
            });
        default:
            return () => { };
    }
}
async function addE2ETestRunner(tree, options) {
    switch (options.e2eTestRunner) {
        case test_runners_1.E2eTestRunner.Cypress:
            const { cypressInitGenerator } = (0, devkit_1.ensurePackage)('@nx/cypress', versions_1.nxVersion);
            return cypressInitGenerator(tree, {
                skipPackageJson: options.skipPackageJson,
            });
        case test_runners_1.E2eTestRunner.Playwright:
            const { initGenerator: playwrightInitGenerator } = (0, devkit_1.ensurePackage)('@nx/playwright', versions_1.nxVersion);
            return playwrightInitGenerator(tree, {
                skipFormat: true,
                skipPackageJson: options.skipPackageJson,
            });
        default:
            return () => { };
    }
}
function ignoreAngularCacheDirectory(tree) {
    const { cli } = (0, devkit_1.readNxJson)(tree);
    // angular-specific cli config is supported though is not included in the
    // NxJsonConfiguration type
    const angularCacheDir = cli?.cache?.path ?? '.angular';
    addGitIgnoreEntry(tree, angularCacheDir);
    addPrettierIgnoreEntry(tree, angularCacheDir);
}
function addGitIgnoreEntry(tree, entry) {
    if (tree.exists('.gitignore')) {
        let content = tree.read('.gitignore', 'utf-8');
        if (/^\.angular$/gm.test(content)) {
            return;
        }
        content = `${content}\n${entry}\n`;
        tree.write('.gitignore', content);
    }
    else {
        devkit_1.logger.warn(`Couldn't find .gitignore file to update`);
    }
}
function addPrettierIgnoreEntry(tree, entry) {
    if (!tree.exists('.prettierignore')) {
        return;
    }
    let content = tree.read('.prettierignore', 'utf-8');
    if (/^\.angular(\/cache)?$/gm.test(content)) {
        return;
    }
    content = `${content}\n${entry}\n`;
    tree.write('.prettierignore', content);
}
exports.default = angularInitGenerator;
